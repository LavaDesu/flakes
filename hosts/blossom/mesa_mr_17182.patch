From de944602b5706f3da045ba7c73b36562bcc3da0a Mon Sep 17 00:00:00 2001
From: Sviatoslav Peleshko <sviatoslav.peleshko@globallogic.com>
Date: Wed, 10 Aug 2022 16:20:48 +0300
Subject: [PATCH 1/4] isl: Check all channels in
 isl_formats_have_same_bits_per_channel

Cc: 22.2 <mesa-stable>
Signed-off-by: Sviatoslav Peleshko <sviatoslav.peleshko@globallogic.com>
Reviewed-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Reviewed-by: Nanley Chery <nanley.g.chery@intel.com>
---
 src/intel/isl/isl_format.c | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/src/intel/isl/isl_format.c b/src/intel/isl/isl_format.c
index 198ecdc196ff..235d2052df2b 100644
--- a/src/intel/isl/isl_format.c
+++ b/src/intel/isl/isl_format.c
@@ -966,7 +966,10 @@ isl_formats_have_same_bits_per_channel(enum isl_format format1,
    return fmtl1->channels.r.bits == fmtl2->channels.r.bits &&
           fmtl1->channels.g.bits == fmtl2->channels.g.bits &&
           fmtl1->channels.b.bits == fmtl2->channels.b.bits &&
-          fmtl1->channels.a.bits == fmtl2->channels.a.bits;
+          fmtl1->channels.a.bits == fmtl2->channels.a.bits &&
+          fmtl1->channels.l.bits == fmtl2->channels.l.bits &&
+          fmtl1->channels.i.bits == fmtl2->channels.i.bits &&
+          fmtl1->channels.p.bits == fmtl2->channels.p.bits;
 }
 
 /**
-- 
GitLab


From 5ec76397c7203aae9f00d5f3fd8c8484318231a1 Mon Sep 17 00:00:00 2001
From: Sviatoslav Peleshko <sviatoslav.peleshko@globallogic.com>
Date: Tue, 7 Jun 2022 18:42:34 +0300
Subject: [PATCH 2/4] anv: Improve image/view usage bits verification

This change makes usage bits verification closer to the Vulkan spec.
i.e. VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT does not always require all formats
to support all the requested usage bits.
Also, VK_IMAGE_CREATE_EXTENDED_USAGE_BIT, when combined with
VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT can relax the requirements for the
usage supported by the original image format.

v2: Removed strict verification of the format_list_info formats usage
    per chadversary's suggestion. Other minor style/comments tweaks.

v3: Added checking of all compatible formats when
    VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT and VK_IMAGE_CREATE_EXTENDED_USAGE_BIT
    are specified, but no list of possible formats was given.

Cc: 22.2 <mesa-stable>
Closes: https://gitlab.freedesktop.org/mesa/mesa/-/issues/6031
Signed-off-by: Sviatoslav Peleshko <sviatoslav.peleshko@globallogic.com>
Reviewed-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Reviewed-by: Nanley Chery <nanley.g.chery@intel.com>
---
 src/intel/vulkan/anv_formats.c | 272 ++++++++++++++++++++++-----------
 1 file changed, 187 insertions(+), 85 deletions(-)

diff --git a/src/intel/vulkan/anv_formats.c b/src/intel/vulkan/anv_formats.c
index e361036367fc..133fca7f8dff 100644
--- a/src/intel/vulkan/anv_formats.c
+++ b/src/intel/vulkan/anv_formats.c
@@ -989,6 +989,116 @@ void anv_GetPhysicalDeviceFormatProperties2(
    }
 }
 
+static bool
+anv_format_supports_usage(
+   VkFormatFeatureFlags2KHR format_feature_flags,
+   VkImageUsageFlags usage_flags)
+{
+   if (usage_flags & VK_IMAGE_USAGE_TRANSFER_SRC_BIT) {
+      if (!(format_feature_flags & (VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT |
+                                    VK_FORMAT_FEATURE_2_BLIT_SRC_BIT))) {
+         return false;
+      }
+   }
+
+   if (usage_flags & VK_IMAGE_USAGE_TRANSFER_DST_BIT) {
+      if (!(format_feature_flags & (VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT |
+                                    VK_FORMAT_FEATURE_2_BLIT_DST_BIT))) {
+         return false;
+      }
+   }
+
+   if (usage_flags & VK_IMAGE_USAGE_SAMPLED_BIT) {
+      if (!(format_feature_flags & VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT)) {
+         return false;
+      }
+   }
+
+   if (usage_flags & VK_IMAGE_USAGE_STORAGE_BIT) {
+      if (!(format_feature_flags & VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT)) {
+         return false;
+      }
+   }
+
+   if (usage_flags & VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT) {
+      if (!(format_feature_flags & VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT)) {
+         return false;
+      }
+   }
+
+   if (usage_flags & VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) {
+      if (!(format_feature_flags & VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT)) {
+         return false;
+      }
+   }
+
+   if (usage_flags & VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT) {
+      /* Nothing to check. */
+   }
+
+   if (usage_flags & VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT) {
+      /* Ignore this flag because it was removed from the
+       * provisional_I_20150910 header.
+       */
+   }
+
+   return true;
+}
+
+static bool
+anv_formats_are_compatible(
+   const struct anv_format *img_fmt, const struct anv_format *img_view_fmt,
+   const struct intel_device_info *devinfo, VkImageTiling tiling)
+{
+   if (img_view_fmt->vk_format == VK_FORMAT_UNDEFINED)
+      return false;
+
+   if (img_fmt == img_view_fmt)
+      return true;
+
+   /* TODO: Handle multi-planar images that can have view of a plane with
+    * possibly different type.
+    */
+   if (img_fmt->n_planes != 1 || img_view_fmt->n_planes != 1)
+      return false;
+
+   const enum isl_format img_isl_fmt =
+      anv_get_format_plane(devinfo, img_fmt->vk_format, 0, tiling).isl_format;
+   const enum isl_format img_view_isl_fmt =
+      anv_get_format_plane(devinfo, img_view_fmt->vk_format, 0, tiling).isl_format;
+   if (img_isl_fmt == ISL_FORMAT_UNSUPPORTED ||
+       img_view_isl_fmt == ISL_FORMAT_UNSUPPORTED)
+      return false;
+
+   /* TODO: Handle VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT. */
+   if (isl_format_is_compressed(img_isl_fmt) !=
+       isl_format_is_compressed(img_view_isl_fmt))
+      return false;
+
+   const struct isl_format_layout *img_fmt_layout =
+      isl_format_get_layout(img_isl_fmt);
+   const struct isl_format_layout *img_view_fmt_layout =
+      isl_format_get_layout(img_view_isl_fmt);
+
+   if (!isl_format_is_compressed(img_isl_fmt)) {
+      /* From the Vulkan 1.3.224 spec "43.1.6. Format Compatibility Classes":
+       *
+       *    "Uncompressed color formats are compatible with each other if they
+       *    occupy the same number of bits per texel block."
+       */
+      return img_fmt_layout->bpb == img_view_fmt_layout->bpb;
+   }
+
+   /* From the Vulkan 1.3.224 spec "43.1.6. Format Compatibility Classes":
+    *
+    *    "Compressed color formats are compatible with each other if the only
+    *    difference between them is the numerical type of the uncompressed
+    *    pixels (e.g. signed vs. unsigned, or SRGB vs. UNORM encoding)."
+    */
+   return img_fmt_layout->txc == img_view_fmt_layout->txc &&
+          isl_formats_have_same_bits_per_channel(img_isl_fmt, img_view_isl_fmt);
+}
+
 static VkResult
 anv_get_image_format_properties(
    struct anv_physical_device *physical_device,
@@ -1021,29 +1131,6 @@ anv_get_image_format_properties(
    }
 
    assert(format->vk_format == info->format);
-   format_feature_flags = anv_get_image_format_features2(devinfo, info->format,
-                                                         format, info->tiling,
-                                                         isl_mod_info);
-
-   /* Remove the VkFormatFeatureFlags that are incompatible with any declared
-    * image view format. (Removals are more likely to occur when a DRM format
-    * modifier is present).
-    */
-   if ((info->flags & VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT) && format_list_info) {
-      for (uint32_t i = 0; i < format_list_info->viewFormatCount; ++i) {
-         VkFormat vk_view_format = format_list_info->pViewFormats[i];
-         const struct anv_format *anv_view_format = anv_get_format(vk_view_format);
-         VkFormatFeatureFlags2 view_format_features =
-            anv_get_image_format_features2(devinfo, vk_view_format,
-                                           anv_view_format,
-                                           info->tiling,
-                                           isl_mod_info);
-         format_feature_flags &= view_format_features;
-      }
-   }
-
-   if (!format_feature_flags)
-      goto unsupported;
 
    switch (info->type) {
    default:
@@ -1077,21 +1164,84 @@ anv_get_image_format_properties(
       break;
    }
 
-   /* From the Vulkan 1.2.199 spec:
+   /* From the Vulkan 1.3.218 spec:
     *
-    *    "VK_IMAGE_CREATE_EXTENDED_USAGE_BIT specifies that the image can be
-    *    created with usage flags that are not supported for the format the
-    *    image is created with but are supported for at least one format a
-    *    VkImageView created from the image can have."
+    *    "For images created without VK_IMAGE_CREATE_EXTENDED_USAGE_BIT a usage
+    *    bit is valid if it is supported for the format the image is created with.
+    *    For images created with VK_IMAGE_CREATE_EXTENDED_USAGE_BIT a usage bit
+    *    is valid if it is supported for at least one of the formats
+    *    a VkImageView created from the image can have."
     *
-    * If VK_IMAGE_CREATE_EXTENDED_USAGE_BIT is set, views can be created with
-    * different usage than the image so we can't always filter on usage.
+    *    "VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT specifies that the image can be
+    *    used to create a VkImageView with a different format from the image."
+    *
+    * So, if both VK_IMAGE_CREATE_EXTENDED_USAGE_BIT and
+    * VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT are set, views can be created with
+    * different usage than the image, so we can't always filter on usage.
     * There is one exception to this below for storage.
+    *
+    * TODO: Handle VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT combined
+    * with those flags.
     */
-   const VkImageUsageFlags image_usage = info->usage;
-   VkImageUsageFlags view_usage = image_usage;
-   if (info->flags & VK_IMAGE_CREATE_EXTENDED_USAGE_BIT)
-      view_usage = 0;
+   format_feature_flags = anv_get_image_format_features2(devinfo, info->format,
+                                                         format, info->tiling,
+                                                         isl_mod_info);
+
+   if (!anv_format_supports_usage(format_feature_flags, info->usage)) {
+      /* If image format itself does not support the usage, and we don't allow
+       * views formats to support it, then we can't support this usage at all.
+       */
+      if (!(info->flags & VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT) ||
+          !(info->flags & VK_IMAGE_CREATE_EXTENDED_USAGE_BIT))
+         goto unsupported;
+
+      /* From the Vulkan 1.3.224 spec "43.1.6. Format Compatibility Classes":
+       *
+       *    "Each depth/stencil format is only compatible with itself."
+       *
+       * So, other formats also can't help.
+       */
+      if (vk_format_is_depth_or_stencil(info->format))
+         goto unsupported;
+
+      VkFormatFeatureFlags2 all_formats_feature_flags = format_feature_flags;
+
+      /* We need to check that each of the usage bits are allowed for at least
+       * one of the potential formats.
+       */
+      if (!format_list_info || format_list_info->viewFormatCount == 0) {
+         /* If we specify no list of possible formats, we can assume that
+          * every compatible format is possible and check all of them.
+          */
+         for (uint32_t fmt_arr_ind = 0; fmt_arr_ind < ARRAY_SIZE(anv_formats); ++fmt_arr_ind) {
+            for (uint32_t fmt_ind = 0; fmt_ind < anv_formats[fmt_arr_ind].n_formats; ++fmt_ind) {
+               const struct anv_format *possible_anv_format = &(anv_formats[fmt_arr_ind].formats[fmt_ind]);
+
+               if (anv_formats_are_compatible(format, possible_anv_format, devinfo, info->tiling)) {
+                  VkFormatFeatureFlags2KHR view_format_features =
+                        anv_get_image_format_features2(devinfo, possible_anv_format->vk_format,
+                                                       possible_anv_format, info->tiling,
+                                                       isl_mod_info);
+                  all_formats_feature_flags |= view_format_features;
+               }
+            }
+         }
+      } else {
+         /* If we provide the list of possible formats, then check just them.
+          */
+         for (uint32_t i = 0; i < format_list_info->viewFormatCount; ++i) {
+            VkFormat vk_view_format = format_list_info->pViewFormats[i];
+            const struct anv_format *anv_view_format = anv_get_format(vk_view_format);
+            VkFormatFeatureFlags2KHR view_format_features =
+                  anv_get_image_format_features2(devinfo, vk_view_format, anv_view_format,
+                                                 info->tiling, isl_mod_info);
+            all_formats_feature_flags |= view_format_features;
+         }
+      }
+
+      if (!anv_format_supports_usage(all_formats_feature_flags, info->usage))
+         goto unsupported;
+   }
 
    if (info->tiling == VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT) {
       /* We support modifiers only for "simple" (that is, non-array
@@ -1110,7 +1260,7 @@ anv_get_image_format_properties(
 
       if (isl_mod_info->aux_usage == ISL_AUX_USAGE_CCS_E &&
           !anv_formats_ccs_e_compatible(devinfo, info->flags, info->format,
-                                        info->tiling, image_usage,
+                                        info->tiling, info->usage,
                                         format_list_info)) {
          goto unsupported;
       }
@@ -1132,32 +1282,12 @@ anv_get_image_format_properties(
        (format_feature_flags & (VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT |
                                 VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT)) &&
        !(info->flags & VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT) &&
-       !(image_usage & VK_IMAGE_USAGE_STORAGE_BIT) &&
+       !(info->usage & VK_IMAGE_USAGE_STORAGE_BIT) &&
        isl_format_supports_multisampling(devinfo, format->planes[0].isl_format)) {
       sampleCounts = isl_device_get_sample_counts(&physical_device->isl_dev);
    }
 
-   if (view_usage & VK_IMAGE_USAGE_TRANSFER_SRC_BIT) {
-      if (!(format_feature_flags & (VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT |
-                                    VK_FORMAT_FEATURE_2_BLIT_SRC_BIT))) {
-         goto unsupported;
-      }
-   }
-
-   if (view_usage & VK_IMAGE_USAGE_TRANSFER_DST_BIT) {
-      if (!(format_feature_flags & (VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT |
-                                    VK_FORMAT_FEATURE_2_BLIT_DST_BIT))) {
-         goto unsupported;
-      }
-   }
-
-   if (view_usage & VK_IMAGE_USAGE_SAMPLED_BIT) {
-      if (!(format_feature_flags & VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT)) {
-         goto unsupported;
-      }
-   }
-
-   if (image_usage & VK_IMAGE_USAGE_STORAGE_BIT) {
+   if (info->usage & VK_IMAGE_USAGE_STORAGE_BIT) {
       /* Non-power-of-two formats can never be used as storage images.  We
        * only check plane 0 because there are no YCbCr formats with
        * non-power-of-two planes.
@@ -1168,24 +1298,6 @@ anv_get_image_format_properties(
          goto unsupported;
    }
 
-   if (view_usage & VK_IMAGE_USAGE_STORAGE_BIT) {
-      if (!(format_feature_flags & VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT)) {
-         goto unsupported;
-      }
-   }
-
-   if (view_usage & VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT) {
-      if (!(format_feature_flags & VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT)) {
-         goto unsupported;
-      }
-   }
-
-   if (view_usage & VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) {
-      if (!(format_feature_flags & VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT)) {
-         goto unsupported;
-      }
-   }
-
    if (info->flags & VK_IMAGE_CREATE_DISJOINT_BIT) {
       /* From the Vulkan 1.2.149 spec, VkImageCreateInfo:
        *
@@ -1240,16 +1352,6 @@ anv_get_image_format_properties(
       }
    }
 
-   if (image_usage & VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT) {
-      /* Nothing to check. */
-   }
-
-   if (image_usage & VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT) {
-      /* Ignore this flag because it was removed from the
-       * provisional_I_20150910 header.
-       */
-   }
-
    /* From the bspec section entitled "Surface Layout and Tiling",
     * Gfx9 has a 256 GB limitation and Gfx11+ has a 16 TB limitation.
     */
-- 
GitLab


From 9eeb26cd53a921d48686578d241ab51291a06717 Mon Sep 17 00:00:00 2001
From: Sviatoslav Peleshko <sviatoslav.peleshko@globallogic.com>
Date: Fri, 12 Aug 2022 22:27:19 +0300
Subject: [PATCH 3/4] anv: split out format list feature gathering

Cc: 22.2 <mesa-stable>
Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Reviewed-by: Sviatoslav Peleshko <sviatoslav.peleshko@globallogic.com>
Reviewed-by: Nanley Chery <nanley.g.chery@intel.com>
---
 src/intel/vulkan/anv_formats.c | 97 ++++++++++++++++++++++------------
 1 file changed, 64 insertions(+), 33 deletions(-)

diff --git a/src/intel/vulkan/anv_formats.c b/src/intel/vulkan/anv_formats.c
index 133fca7f8dff..0ed3542fe520 100644
--- a/src/intel/vulkan/anv_formats.c
+++ b/src/intel/vulkan/anv_formats.c
@@ -1099,6 +1099,65 @@ anv_formats_are_compatible(
           isl_formats_have_same_bits_per_channel(img_isl_fmt, img_view_isl_fmt);
 }
 
+/* Returns a set of feature flags supported by any of the VkFormat listed in
+ * format_list_info or any VkFormat compatible with format.
+ */
+static VkFormatFeatureFlags2
+anv_formats_gather_format_features(
+   const struct intel_device_info *devinfo,
+   const struct anv_format *format,
+   VkImageTiling tiling,
+   const struct isl_drm_modifier_info *isl_mod_info,
+   const VkImageFormatListCreateInfo *format_list_info)
+{
+   VkFormatFeatureFlags2KHR all_formats_feature_flags = 0;
+
+   /* We need to check that each of the usage bits are allowed for at least
+    * one of the potential formats.
+    */
+   if (!format_list_info || format_list_info->viewFormatCount == 0) {
+      /* If we specify no list of possible formats, we need to assume that
+       * every compatible format is possible and consider the features
+       * supported by each of them.
+       */
+      for (uint32_t fmt_arr_ind = 0;
+           fmt_arr_ind < ARRAY_SIZE(anv_formats);
+           ++fmt_arr_ind) {
+         for (uint32_t fmt_ind = 0;
+              fmt_ind < anv_formats[fmt_arr_ind].n_formats;
+              ++fmt_ind) {
+            const struct anv_format *possible_anv_format =
+               &(anv_formats[fmt_arr_ind].formats[fmt_ind]);
+
+            if (anv_formats_are_compatible(format, possible_anv_format,
+                                           devinfo, tiling)) {
+               VkFormatFeatureFlags2KHR view_format_features =
+                  anv_get_image_format_features2(devinfo,
+                                                 possible_anv_format->vk_format,
+                                                 possible_anv_format, tiling,
+                                                 isl_mod_info);
+               all_formats_feature_flags |= view_format_features;
+            }
+         }
+      }
+   } else {
+      /* If we provide the list of possible formats, then check just them. */
+      for (uint32_t i = 0; i < format_list_info->viewFormatCount; ++i) {
+         VkFormat vk_view_format = format_list_info->pViewFormats[i];
+         const struct anv_format *anv_view_format =
+            anv_get_format(vk_view_format);
+         VkFormatFeatureFlags2KHR view_format_features =
+            anv_get_image_format_features2(devinfo, vk_view_format,
+                                           anv_view_format, tiling,
+                                           isl_mod_info);
+         all_formats_feature_flags |= view_format_features;
+      }
+   }
+
+   return all_formats_feature_flags;
+}
+
+
 static VkResult
 anv_get_image_format_properties(
    struct anv_physical_device *physical_device,
@@ -1204,40 +1263,12 @@ anv_get_image_format_properties(
       if (vk_format_is_depth_or_stencil(info->format))
          goto unsupported;
 
-      VkFormatFeatureFlags2 all_formats_feature_flags = format_feature_flags;
-
-      /* We need to check that each of the usage bits are allowed for at least
-       * one of the potential formats.
+      /* Gather all possible format feature flags for the formats listed in
+       * the format list or all the compatible formats.
        */
-      if (!format_list_info || format_list_info->viewFormatCount == 0) {
-         /* If we specify no list of possible formats, we can assume that
-          * every compatible format is possible and check all of them.
-          */
-         for (uint32_t fmt_arr_ind = 0; fmt_arr_ind < ARRAY_SIZE(anv_formats); ++fmt_arr_ind) {
-            for (uint32_t fmt_ind = 0; fmt_ind < anv_formats[fmt_arr_ind].n_formats; ++fmt_ind) {
-               const struct anv_format *possible_anv_format = &(anv_formats[fmt_arr_ind].formats[fmt_ind]);
-
-               if (anv_formats_are_compatible(format, possible_anv_format, devinfo, info->tiling)) {
-                  VkFormatFeatureFlags2KHR view_format_features =
-                        anv_get_image_format_features2(devinfo, possible_anv_format->vk_format,
-                                                       possible_anv_format, info->tiling,
-                                                       isl_mod_info);
-                  all_formats_feature_flags |= view_format_features;
-               }
-            }
-         }
-      } else {
-         /* If we provide the list of possible formats, then check just them.
-          */
-         for (uint32_t i = 0; i < format_list_info->viewFormatCount; ++i) {
-            VkFormat vk_view_format = format_list_info->pViewFormats[i];
-            const struct anv_format *anv_view_format = anv_get_format(vk_view_format);
-            VkFormatFeatureFlags2KHR view_format_features =
-                  anv_get_image_format_features2(devinfo, vk_view_format, anv_view_format,
-                                                 info->tiling, isl_mod_info);
-            all_formats_feature_flags |= view_format_features;
-         }
-      }
+      VkFormatFeatureFlags2 all_formats_feature_flags = format_feature_flags |
+         anv_formats_gather_format_features(devinfo, format, info->tiling,
+                                            isl_mod_info, format_list_info);
 
       if (!anv_format_supports_usage(all_formats_feature_flags, info->usage))
          goto unsupported;
-- 
GitLab


From 2fd6d90412ba7d311bcd94a46105836ef073e6ba Mon Sep 17 00:00:00 2001
From: Sviatoslav Peleshko <sviatoslav.peleshko@globallogic.com>
Date: Thu, 6 Oct 2022 17:31:07 +0300
Subject: [PATCH 4/4] zink/ci: Add zink-anv-tgl fails expected due to stricter
 usage validation

Signed-off-by: Sviatoslav Peleshko <sviatoslav.peleshko@globallogic.com>
---
 .../drivers/zink/ci/zink-anv-tgl-fails.txt    | 215 ++++++++++++++++++
 1 file changed, 215 insertions(+)

diff --git a/src/gallium/drivers/zink/ci/zink-anv-tgl-fails.txt b/src/gallium/drivers/zink/ci/zink-anv-tgl-fails.txt
index e69de29bb2d1..c4dd948333ec 100644
--- a/src/gallium/drivers/zink/ci/zink-anv-tgl-fails.txt
+++ b/src/gallium/drivers/zink/ci/zink-anv-tgl-fails.txt
@@ -0,0 +1,215 @@
+# https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/17182
+KHR-GL46.buffer_storage.map_persistent_texture,Fail
+KHR-GL46.copy_image.incompatible_formats_compression,Fail
+KHR-GL46.copy_image.invalid_alignment,Fail
+KHR-GL46.copy_image.smoke_test,Fail
+KHR-GL46.direct_state_access.textures_compressed_subimage,Fail
+KHR-GL46.direct_state_access.textures_get_image,Fail
+KHR-GL46.direct_state_access.textures_image_query_errors,Fail
+KHR-GL46.direct_state_access.textures_subimage_errors,Fail
+KHR-GL46.get_texture_sub_image.errors_test,Fail
+KHR-GL46.get_texture_sub_image.functional_test,Fail
+KHR-GL46.internalformat.copy_tex_image.rgb9_e5,Fail
+KHR-GL46.internalformat.texture2d.rgba_unsigned_byte_rgb9_e5,Fail
+KHR-GL46.packed_pixels.pbo_rectangle.compressed_red,Fail
+KHR-GL46.packed_pixels.pbo_rectangle.compressed_red_rgtc1,Fail
+KHR-GL46.packed_pixels.pbo_rectangle.compressed_rg,Fail
+KHR-GL46.packed_pixels.pbo_rectangle.compressed_rg_rgtc2,Fail
+KHR-GL46.packed_pixels.pbo_rectangle.compressed_rgb,Fail
+KHR-GL46.packed_pixels.pbo_rectangle.compressed_rgba,Fail
+KHR-GL46.packed_pixels.pbo_rectangle.compressed_signed_red_rgtc1,Fail
+KHR-GL46.packed_pixels.pbo_rectangle.compressed_signed_rg_rgtc2,Fail
+KHR-GL46.packed_pixels.pbo_rectangle.compressed_srgb,Fail
+KHR-GL46.packed_pixels.pbo_rectangle.compressed_srgb_alpha,Fail
+KHR-GL46.packed_pixels.pbo_rectangle.rgb9_e5,Fail
+KHR-GL46.packed_pixels.rectangle.compressed_red,Fail
+KHR-GL46.packed_pixels.rectangle.compressed_red_rgtc1,Fail
+KHR-GL46.packed_pixels.rectangle.compressed_rg,Fail
+KHR-GL46.packed_pixels.rectangle.compressed_rg_rgtc2,Fail
+KHR-GL46.packed_pixels.rectangle.compressed_rgb,Fail
+KHR-GL46.packed_pixels.rectangle.compressed_rgba,Fail
+KHR-GL46.packed_pixels.rectangle.compressed_signed_red_rgtc1,Fail
+KHR-GL46.packed_pixels.rectangle.compressed_signed_rg_rgtc2,Fail
+KHR-GL46.packed_pixels.rectangle.compressed_srgb,Fail
+KHR-GL46.packed_pixels.rectangle.compressed_srgb_alpha,Fail
+KHR-GL46.packed_pixels.rectangle.rgb9_e5,Fail
+KHR-GL46.packed_pixels.varied_rectangle.compressed_red,Fail
+KHR-GL46.packed_pixels.varied_rectangle.compressed_red_rgtc1,Fail
+KHR-GL46.packed_pixels.varied_rectangle.compressed_rg,Fail
+KHR-GL46.packed_pixels.varied_rectangle.compressed_rg_rgtc2,Fail
+KHR-GL46.packed_pixels.varied_rectangle.compressed_rgb,Fail
+KHR-GL46.packed_pixels.varied_rectangle.compressed_rgba,Fail
+KHR-GL46.packed_pixels.varied_rectangle.compressed_signed_red_rgtc1,Fail
+KHR-GL46.packed_pixels.varied_rectangle.compressed_signed_rg_rgtc2,Fail
+KHR-GL46.packed_pixels.varied_rectangle.compressed_srgb,Fail
+KHR-GL46.packed_pixels.varied_rectangle.compressed_srgb_alpha,Fail
+KHR-GL46.packed_pixels.varied_rectangle.rgb9_e5,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage2d.rgb_s3tc_dxt1.0_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage2d.rgb_s3tc_dxt1.0_16,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage2d.rgb_s3tc_dxt1.0_32,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage2d.rgb_s3tc_dxt1.0_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage2d.rgb_s3tc_dxt1.16_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage2d.rgb_s3tc_dxt1.16_16,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage2d.rgb_s3tc_dxt1.16_32,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage2d.rgb_s3tc_dxt1.16_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage2d.rgb_s3tc_dxt1.32_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage2d.rgb_s3tc_dxt1.32_16,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage2d.rgb_s3tc_dxt1.32_32,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage2d.rgb_s3tc_dxt1.32_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage2d.rgb_s3tc_dxt1.4_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage2d.rgb_s3tc_dxt1.4_16,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage2d.rgb_s3tc_dxt1.4_32,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage2d.rgb_s3tc_dxt1.4_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage2d.rgba_astc_8x5.0_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage2d.rgba_astc_8x5.0_15,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage2d.rgba_astc_8x5.0_30,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage2d.rgba_astc_8x5.0_5,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage2d.rgba_astc_8x5.16_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage2d.rgba_astc_8x5.16_15,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage2d.rgba_astc_8x5.16_30,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage2d.rgba_astc_8x5.16_5,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage2d.rgba_astc_8x5.32_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage2d.rgba_astc_8x5.32_15,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage2d.rgba_astc_8x5.32_30,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage2d.rgba_astc_8x5.32_5,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage2d.rgba_astc_8x5.8_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage2d.rgba_astc_8x5.8_15,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage2d.rgba_astc_8x5.8_30,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage2d.rgba_astc_8x5.8_5,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.0_0_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.0_0_1,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.0_0_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.0_0_8,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.0_16_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.0_16_1,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.0_16_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.0_16_8,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.0_32_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.0_32_1,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.0_32_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.0_32_8,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.0_4_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.0_4_1,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.0_4_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.0_4_8,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.16_0_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.16_0_1,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.16_0_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.16_0_8,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.16_16_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.16_16_1,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.16_16_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.16_16_8,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.16_32_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.16_32_1,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.16_32_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.16_32_8,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.16_4_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.16_4_1,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.16_4_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.16_4_8,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.32_0_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.32_0_1,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.32_0_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.32_0_8,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.32_16_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.32_16_1,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.32_16_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.32_16_8,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.32_32_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.32_32_1,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.32_32_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.32_32_8,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.32_4_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.32_4_1,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.32_4_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.32_4_8,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.4_0_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.4_0_1,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.4_0_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.4_0_8,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.4_16_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.4_16_1,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.4_16_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.4_16_8,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.4_32_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.4_32_1,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.4_32_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.4_32_8,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.4_4_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.4_4_1,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.4_4_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgb_s3tc_dxt1.4_4_8,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.0_0_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.0_0_1,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.0_0_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.0_0_8,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.0_15_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.0_15_1,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.0_15_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.0_15_8,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.0_30_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.0_30_1,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.0_30_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.0_30_8,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.0_5_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.0_5_1,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.0_5_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.0_5_8,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.16_0_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.16_0_1,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.16_0_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.16_0_8,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.16_15_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.16_15_1,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.16_15_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.16_15_8,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.16_30_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.16_30_1,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.16_30_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.16_30_8,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.16_5_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.16_5_1,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.16_5_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.16_5_8,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.32_0_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.32_0_1,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.32_0_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.32_0_8,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.32_15_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.32_15_1,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.32_15_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.32_15_8,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.32_30_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.32_30_1,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.32_30_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.32_30_8,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.32_5_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.32_5_1,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.32_5_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.32_5_8,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.8_0_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.8_0_1,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.8_0_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.8_0_8,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.8_15_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.8_15_1,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.8_15_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.8_15_8,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.8_30_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.8_30_1,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.8_30_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.8_30_8,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.8_5_0,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.8_5_1,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.8_5_4,Fail
+KHR-GL46.pixelstoragemodes.compressedteximage3d.rgba_astc_8x5.8_5_8,Fail
+KHR-GL46.texture_border_clamp.Texture2DArrayCompressed,Fail
+KHR-GL46.texture_border_clamp.Texture2DArrayCompressedLinear,Fail
+KHR-GL46.texture_border_clamp.Texture2DCompressed,Fail
+KHR-GL46.texture_border_clamp.Texture2DCompressedLinear,Fail
+KHR-GL46.texture_cube_map_array.etc2_texture,Fail
+KHR-GL46.texture_filter_anisotropic.drawing,Fail
+KHR-GL46.texture_size_promotion.functional,Fail
+KHR-GL46.texture_view.errors,Fail
+KHR-GL46.texture_view.view_classes,Fail
-- 
GitLab

